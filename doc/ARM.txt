int main() {
	
	int temp_array[3] = { 1, 2, 3 };
	
	temp_array[1] = 17;
	
	return 0;
}



-- ARM

.LC0:
        .word   1
        .word   2
        .word   3
main:
        push    {r4, r7}
        sub     sp, sp, #16
        add     r7, sp, #0
        movw    r3, #:lower16:.LC0
        movt    r3, #:upper16:.LC0
        adds    r4, r7, #4
        ldm     r3, {r0, r1, r2}
        stm     r4, {r0, r1, r2}
        movs    r3, #17
        str     r3, [r7, #8]
        movs    r3, #0
        mov     r0, r3
        adds    r7, r7, #16
        mov     sp, r7
        pop     {r4, r7}
        bx      lr
		
		
		
# LINKS

https://student.cs.uwaterloo.ca/~cs452/docs/ts7200/arm-architecture.pdf
https://shell-storm.org/online/Online-Assembler-and-Disassembler
https://developer.arm.com/documentation/ddi0403/ee/?lang=en <----- ARMv7-M Architecture Reference Manual





# UAL - Arm Unified Assembler Language

This document uses the Arm Unified Assembler Language (UAL). This assembly language syntax provides a
canonical form for all Arm and Thumb instructions.
UAL describes the syntax for the mnemonic and the operands of each instruction. In addition, it assumes that
instructions and data items can be given labels. It does not specify the syntax to be used for labels, nor what
assembler directives and options are available. See your assembler documentation for these details.
Earlier Arm assembly language mnemonics are still supported as synonyms, as described in the instruction details.







# ADD - ARM (thumb)

A7.1.8 ADD (6)

```
add     r7, sp, #0
```

little-endian machine code: 00 af 
00 af -> af00h
10101111 00000000
[10101][111][00000000]
        Rd   immed_8
		
The sp (stack pointer) register is not encoded but is implicitly assumed with the opcode 10101.
Rd is the destination register. r7 in this case.
immed_8 is the immediate #8 here.




# MOV - Register, Register - ARM (thumb)

A7.1.44 MOV (3) - PDF page 591

1. Open https://shell-storm.org/online/Online-Assembler-and-Disassembler
2. Select ARM (thumb)
3. Select Hex
4. Paste: mov r0, r3
5. Click "Assemble"

```
mov r0, r3
```

This produces little-endian machine code: 18 46 (which is hex)

Disassembling:

1. Convert the value stored in little-endian format to a normal number
1846h --> 4618h

2. Convert 4618h to a binary number
01000110 00011000 b

3. Compare this bit pattern to A7.1.44 MOV (3) - PDF page 591

[01000110] [0] [0] [011] [000]
           H1  H2  Rm    Rd
		   
4. To decode the destination register, build H1+Rd = 0000d = 0d ==> r0

4. To decode the source register, build H2+Rm = 0011d = 3d ==> r3




# PUSH - ARM (thumb)

A7.1.50 PUSH - PDF page 601

The command is flexible in that the curly brackets allow a flexible list of registers to save to the stack.
The registers allowed in the list are r0-r7.
To encode which register are stored, the second byte called "Register List" is a bit field where a bit is
set to 1 if the register has to be stored to the stack.
The register LR can also be stored. If LR should be stored, the "R" bit is set to 1.
LR is the is the Link Register (LR) Register 14 (see PDF page 29)

```
push    {r4, r7}
```
little-endian machine code: 90 b4
90 b4 -> b490h
10110100 10010000
[1011010] [0] [10010000]
          R   Register List

```	  
push    {r0, r1, r2}  
```
07 b4 -> b407h		  
10110100 00000111
[1011010] [0] [00000111]
          R   Register List

```
push    {r0, r1, r2, r3, r4, r5, r6, r7}
```
ff b4 -> b4ffh
10110100 11111111
[1011010] [0] [11111111]
          R   Register List




# MOVW - ARM (thumb)

This instruction is defined inside the "ARMv7-M Architecture Reference Manual" and not in the "ARM Architecture Reference Manual".

https://stackoverflow.com/questions/7800055/movw-and-movt-in-arm-assembly

```
movw    r3, #:lower16:.LC0
```

```
movw    r1, 0x5c18
```

Machine Code little-endian 45 f6 18 41 

First, convert it to a normal 32 bit number
45 f6 18 41 
[45 f6] [18 41] --> [f6 45] [41 18] --> f6454118

11110110 01000101 01000001 00011000

[11110][1][10][0][1][0][0][0101][0][100][0001][00011000]
        i                  imm4     imm3 Rd    imm8





